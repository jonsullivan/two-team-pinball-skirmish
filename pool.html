
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Two-Team Pinball Skirmish</title>
  <style>
    /* Full-viewport canvas */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0f1223; /* dark spacey backdrop */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      color: #e8ecf1;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }

    /* HUD overlay */
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 10;
      background: rgba(8, 12, 24, 0.6);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 10px;
      padding: 10px 12px;
      backdrop-filter: saturate(150%) blur(4px);
      user-select: none;
    }
    .hud h1 {
      margin: 0 0 6px;
      font-size: 16px;
      letter-spacing: 0.3px;
    }
    .hud .row {
      display: flex;
      gap: 24px;
      font-size: 14px;
      align-items: center;
    }
    .hud .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 9999px;
      border: 1px solid rgba(255,255,255,0.16);
      font-size: 12px;
      margin-left: 6px;
    }
    .legend {
      margin-top: 6px;
      font-size: 12px;
      line-height: 1.35;
      opacity: 0.8;
    }

    /* Goal lines */
    .goal-left, .goal-right {
      position: fixed;
      top: 0;
      width: 12px;
      height: 100vh;
      z-index: 5;
      pointer-events: none;
      opacity: 0.3;
    }
    .goal-left { left: 0; background: linear-gradient(180deg, #00b2ff55, #00b2ff00); }
    .goal-right { right: 0; background: linear-gradient(180deg, #ff4d4d55, #ff4d4d00); }

    /* Difficulty control (optional quick toggles) */
    .difficulty {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }
    .difficulty button {
      background: #1a2144;
      color: #e8ecf1;
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .difficulty button:hover { background: #23306b; }
  </style>
</head>
<body>
  <div class="goal-left"></div>
  <div class="goal-right"></div>
  <div class="hud">
    <h1>Two-Team Pinball Skirmish</h1>
    <div class="row">
      <div>Blue (You) Score: <strong id="scoreHuman">0</strong></div>
      <div>Red (Bot) Score: <strong id="scoreBot">0</strong></div>
      <div>Active Objects: <span id="activeCount" class="badge">0</span></div>
    </div>
    <div class="legend">
      Mouse/Touch: drag from the <strong>left edge</strong> to set angle &amp; power, release to launch.<br />
      <strong>E</strong>/<strong>M</strong>/<strong>H</strong>: difficulty presets (Easy/Medium/Hard). <strong>Space</strong>: pause. <strong>R</strong>: reset.
    </div>
    <div class="difficulty">
      <button data-diff="easy">Easy</button>
      <button data-diff="medium">Medium</button>
      <button data-diff="hard">Hard</button>
    </div>
  </div>
  <canvas id="game"></canvas>

  <script>
    // =========================
    // Configuration Object
    // =========================
    const CONFIG = {
      general: {
        friction: 0.00025,     // slows over time (per ms)
        gravity: 0,            // you can set gravity if desired
        bounceDamping: 0.92,   // velocity retained after a bounce
        maxObjects: 200,       // global cap on live objects
        popOnOppositeCollision: true,
        goalPaddingPx: 6,      // how far inside the edge counts as "goal"
        dprScale: true,        // use devicePixelRatio for crisp rendering
        trail: false           // set true to draw motion trails
      },
      human: {
        color: "#00b2ff",
        radius: 12,
        maxPowerPx: 360,       // maximum arrow length for launch power
        powerToSpeed: 2.2,     // scales arrow length -> initial speed (px/s)
        cooldownMs: 120,       // minimum time between launches
        batch: 1,              // how many objects per launch
        spread: 0.04,          // random angle spread per batch
        spawnSide: "left"      // anchor side for human launch
      },
      bot: {
        color: "#ff4d4d",
        radius: 12,
        spawnIntervalMs: 900,  // time between bot bursts
        burstSize: 2,          // how many per burst
        minSpeed: 180,         // initial speed range
        maxSpeed: 520,
        varianceAngle: 0.50,   // random angle off "toward the other side"
        spawnSide: "right"     // anchor side for bot launch
      },
      presets: {
        easy: {
          human: { maxPowerPx: 380, batch: 2, spread: 0.03 },
          bot:   { spawnIntervalMs: 1200, burstSize: 1, minSpeed: 160, maxSpeed: 360, varianceAngle: 0.45 }
        },
        medium: {
          human: { maxPowerPx: 340, batch: 1, spread: 0.04 },
          bot:   { spawnIntervalMs: 900, burstSize: 2, minSpeed: 200, maxSpeed: 520, varianceAngle: 0.50 }
        },
        hard: {
          human: { maxPowerPx: 300, batch: 1, spread: 0.06 },
          bot:   { spawnIntervalMs: 650, burstSize: 3, minSpeed: 280, maxSpeed: 680, varianceAngle: 0.65 }
        }
      }
    };

    // =========================
    // Canvas & State
    // =========================
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    let dpr = window.devicePixelRatio || 1;
    let W = 0, H = 0;

    function resizeCanvas() {
      dpr = CONFIG.general.dprScale ? (window.devicePixelRatio || 1) : 1;
      W = Math.floor(window.innerWidth * dpr);
      H = Math.floor(window.innerHeight * dpr);
      canvas.width = W;
      canvas.height = H;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // =========================
    // Game Entities
    // =========================
    const TEAM = { HUMAN: 0, BOT: 1 };

    class Ball {
      constructor(x, y, vx, vy, team, radius, color) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.team = team;
        this.radius = radius;
        this.color = color;
        this.alive = true;
        this.age = 0;
      }
      update(dt) {
        const friction = CONFIG.general.friction;
        const grav = CONFIG.general.gravity;

        // Apply friction (proportional to dt)
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > 0) {
          const decel = friction * dt * speed;
          const scale = Math.max(0, (speed - decel) / speed);
          this.vx *= scale;
          this.vy *= scale;
        }

        // Gravity
        this.vy += grav * dt / 1000;

        // Integrate
        this.x += this.vx * dt / 1000;
        this.y += this.vy * dt / 1000;

        // Bounce off top/bottom
        if (this.y - this.radius < 0) {
          this.y = this.radius;
          this.vy = -this.vy * CONFIG.general.bounceDamping;
        } else if (this.y + this.radius > canvas.height / dpr) {
          this.y = (canvas.height / dpr) - this.radius;
          this.vy = -this.vy * CONFIG.general.bounceDamping;
        }

        // Goal detection: reaching the far side disappears & scores
        const pad = CONFIG.general.goalPaddingPx;
        if (this.team === TEAM.HUMAN) {
          // Human tries to reach RIGHT side
          if (this.x + this.radius >= (canvas.width / dpr) - pad) {
            scoreHuman++;
            this.alive = false;
            spawnPop(this.x, this.y, this.color);
          }
        } else {
          // Bot tries to reach LEFT side
          if (this.x - this.radius <= pad) {
            scoreBot++;
            this.alive = false;
            spawnPop(this.x, this.y, this.color);
          }
        }

        this.age += dt;
      }
      draw(ctx) {
        // Ball
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.shadowColor = this.color + "88";
        ctx.shadowBlur = 12;
        ctx.fill();

        // Subtle outline
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#ffffff20";
        ctx.stroke();

        // Optional trailing indicator
        if (CONFIG.general.trail) {
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x - this.vx * 0.02, this.y - this.vy * 0.02);
          ctx.strokeStyle = this.color + "55";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
    }

    // Simple pop/explosion effect
    class Pop {
      constructor(x, y, color) {
        this.x = x; this.y = y;
        this.color = color;
        this.life = 400; // ms
        this.age = 0;
        this.r = 8;
      }
      update(dt) {
        this.age += dt;
        this.r += dt * 0.04;
      }
      draw(ctx) {
        const t = Math.min(1, this.age / this.life);
        const alpha = 1 - t;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.strokeStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, "0");
        ctx.lineWidth = 2 + (1 - alpha) * 2;
        ctx.stroke();
      }
      get alive() { return this.age < this.life; }
    }

    // =========================
    // Game State & Utilities
    // =========================
    let balls = [];
    let pops = [];
    let paused = false;
    let scoreHuman = 0;
    let scoreBot = 0;

    const scoreHumanEl = document.getElementById("scoreHuman");
    const scoreBotEl = document.getElementById("scoreBot");
    const activeEl = document.getElementById("activeCount");
    const difficultyButtons = document.querySelectorAll(".difficulty button");

    function spawnPop(x, y, color) {
      pops.push(new Pop(x, y, color));
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    // =========================
    // Collision (Opposing teams)
    // =========================
    function handleCollisions() {
      for (let i = 0; i < balls.length; i++) {
        const a = balls[i];
        if (!a.alive) continue;
        for (let j = i + 1; j < balls.length; j++) {
          const b = balls[j];
          if (!b.alive) continue;
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const r = a.radius + b.radius;
          if (dx * dx + dy * dy <= r * r) {
            if (CONFIG.general.popOnOppositeCollision && a.team !== b.team) {
              // Both disappear on opposing collision
              a.alive = false;
              b.alive = false;
              const mx = (a.x + b.x) / 2;
              const my = (a.y + b.y) / 2;
              spawnPop(mx, my, "#ffffff");
            } else {
              // Optional same-team bounce (not required); mild separation
              const dist = Math.max(1, Math.hypot(dx, dy));
              const nx = dx / dist, ny = dy / dist;
              const overlap = r - dist;
              const push = overlap * 0.5;
              a.x -= nx * push; a.y -= ny * push;
              b.x += nx * push; b.y += ny * push;
              const rvx = b.vx - a.vx, rvy = b.vy - a.vy;
              const sep = (rvx * nx + rvy * ny);
              const impulse = sep * 0.4;
              a.vx += nx * impulse; a.vy += ny * impulse;
              b.vx -= nx * impulse; b.vy -= ny * impulse;
            }
          }
        }
      }
    }

    // =========================
    // Launchers
    // =========================
    let aiming = false;
    let aimAnchor = { x: 20, y: canvas.height / (dpr * 2) }; // left-side anchor
    let aimCurrent = { x: 20, y: canvas.height / (dpr * 2) };
    let lastLaunchTs = 0;

    function beginAim(x, y) {
      // Only begin aiming if near the left edge
      const pxX = x, pxY = y;
      const leftZone = 100; // pixels in CSS coords
      if (pxX <= leftZone) {
        aimAnchor = { x: 20, y: pxY };
        aimCurrent = { x: pxX, y: pxY };
        aiming = true;
      }
    }
    function moveAim(x, y) {
      if (aiming) {
        aimCurrent = { x, y };
      }
    }
    function endAim() {
      if (!aiming) return;
      aiming = false;
      const now = performance.now();
      if (now - lastLaunchTs < CONFIG.human.cooldownMs) return;
      lastLaunchTs = now;

      // Compute arrow vector (anchor -> current)
      const ax = aimAnchor.x, ay = aimAnchor.y;
      let vx = aimCurrent.x - ax;
      let vy = aimCurrent.y - ay;
      // Constrain power
      const len = Math.hypot(vx, vy);
      const maxLen = CONFIG.human.maxPowerPx;
      const power = Math.min(len, maxLen);
      if (power < 8) return; // too weak; ignore

      const angle = Math.atan2(vy, vx);
      const speed = power * CONFIG.human.powerToSpeed; // px/s

      // Spawn batch with slight spread
      const n = CONFIG.human.batch;
      for (let i = 0; i < n; i++) {
        const jitter = (Math.random() - 0.5) * CONFIG.human.spread;
        const a = angle + jitter;
        const svx = Math.cos(a) * speed;
        const svy = Math.sin(a) * speed;
        const startX = (CONFIG.human.spawnSide === "left") ? (aimAnchor.x + 16) : (canvas.width / dpr - 16);
        const startY = ay;
        spawnBall(startX, startY, svx, svy, TEAM.HUMAN, CONFIG.human.radius, CONFIG.human.color);
      }
    }

    function spawnBall(x, y, vx, vy, team, radius, color) {
      if (balls.length >= CONFIG.general.maxObjects) return;
      balls.push(new Ball(x, y, vx, vy, team, radius, color));
    }

    // Bot spawns periodically
    let nextBotSpawn = performance.now() + CONFIG.bot.spawnIntervalMs;
    function botSpawner(ts) {
      if (paused) return;
      if (ts >= nextBotSpawn) {
        nextBotSpawn = ts + CONFIG.bot.spawnIntervalMs;

        const n = CONFIG.bot.burstSize;
        for (let i = 0; i < n; i++) {
          const y = (Math.random() * (canvas.height / dpr - 40)) + 20;
          const x = (CONFIG.bot.spawnSide === "right") ? (canvas.width / dpr - 20) : 20;

          // Aim roughly toward the other side, with variance
          const baseAngle = (CONFIG.bot.spawnSide === "right") ? Math.PI : 0; // leftward or rightward
          const angle = baseAngle + (Math.random() - 0.5) * CONFIG.bot.varianceAngle;
          const speed = CONFIG.bot.minSpeed + Math.random() * (CONFIG.bot.maxSpeed - CONFIG.bot.minSpeed);
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;

          spawnBall(x, y, vx, vy, TEAM.BOT, CONFIG.bot.radius, CONFIG.bot.color);
        }
      }
    }

    // =========================
    // Input (Pointer + Keyboard)
    // =========================
    function toCanvasCoords(clientX, clientY) {
      // Canvas CSS pixels map directly because we scaled the context
      return { x: clientX, y: clientY };
    }

    canvas.addEventListener("pointerdown", (e) => {
      const p = toCanvasCoords(e.clientX, e.clientY);
      beginAim(p.x, p.y);
    });
    window.addEventListener("pointermove", (e) => {
      const p = toCanvasCoords(e.clientX, e.clientY);
      moveAim(p.x, p.y);
    });
    window.addEventListener("pointerup", () => endAim());
    window.addEventListener("pointercancel", () => { aiming = false; });

    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === " ") {
        paused = !paused;
      } else if (e.key.toLowerCase() === "r") {
        resetGame();
      } else if (e.key.toLowerCase() === "e") {
        applyPreset("easy");
      } else if (e.key.toLowerCase() === "m") {
        applyPreset("medium");
      } else if (e.key.toLowerCase() === "h") {
        applyPreset("hard");
      }
    });

    difficultyButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        applyPreset(btn.dataset.diff);
      });
    });

    function applyPreset(name) {
      const p = CONFIG.presets[name];
      if (!p) return;
      Object.assign(CONFIG.human, p.human);
      Object.assign(CONFIG.bot, p.bot);
      // Stagger next bot spawn for smoother transition
      nextBotSpawn = performance.now() + CONFIG.bot.spawnIntervalMs;
    }

    function resetGame() {
      balls = [];
      pops = [];
      scoreHuman = 0;
      scoreBot = 0;
      paused = false;
      nextBotSpawn = performance.now() + CONFIG.bot.spawnIntervalMs;
    }

    // =========================
    // Main Loop
    // =========================
    let lastTs = performance.now();
    function loop(ts) {
      const dt = ts - lastTs;
      lastTs = ts;

      // Update spawner
      botSpawner(ts);

      // Update entities
      if (!paused) {
        for (const b of balls) { if (b.alive) b.update(dt); }
        handleCollisions();
        balls = balls.filter(b => b.alive);
        for (const p of pops) { p.update(dt); }
        pops = pops.filter(p => p.alive);
      }

      // Render
      draw();

      // HUD
      scoreHumanEl.textContent = String(scoreHuman);
      scoreBotEl.textContent = String(scoreBot);
      activeEl.textContent = String(balls.length);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function drawBackground(ctx) {
      const w = canvas.width / dpr, h = canvas.height / dpr;
      // Subtle vignette gradient background
      const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h)/1.2);
      g.addColorStop(0, "#0f1223");
      g.addColorStop(1, "#0b0e1b");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, w, h);

      // Center line (just for reference)
      ctx.strokeStyle = "#ffffff10";
      ctx.setLineDash([6, 6]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(w / 2, 0);
      ctx.lineTo(w / 2, h);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawAim(ctx) {
      if (!aiming) return;
      // Arrow from anchor to current
      const ax = aimAnchor.x, ay = aimAnchor.y;
      const cx = aimCurrent.x, cy = aimCurrent.y;
      let dx = cx - ax, dy = cy - ay;
      const len = Math.hypot(dx, dy);
      if (len < 1) return;
      const maxLen = CONFIG.human.maxPowerPx;
      const clampedLen = Math.min(len, maxLen);
      const ux = dx / len, uy = dy / len;
      const tipX = ax + ux * clampedLen;
      const tipY = ay + uy * clampedLen;

      // Line
      ctx.lineWidth = 4;
      ctx.strokeStyle = CONFIG.human.color;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(tipX, tipY);
      ctx.stroke();

      // Arrow head
      const headSize = 10;
      const angle = Math.atan2(uy, ux);
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(tipX - Math.cos(angle - Math.PI/6) * headSize, tipY - Math.sin(angle - Math.PI/6) * headSize);
      ctx.lineTo(tipX - Math.cos(angle + Math.PI/6) * headSize, tipY - Math.sin(angle + Math.PI/6) * headSize);
      ctx.closePath();
      ctx.fillStyle = CONFIG.human.color;
      ctx.fill();

      // Power meter (clamped)
      const powerPct = clampedLen / maxLen;
      ctx.fillStyle = "#ffffff33";
      ctx.fillRect(8, 8, 120, 8);
      ctx.fillStyle = CONFIG.human.color;
      ctx.fillRect(8, 8, 120 * powerPct, 8);
      ctx.strokeStyle = "#ffffff66";
      ctx.lineWidth = 1;
      ctx.strokeRect(8, 8, 120, 8);
    }

    function draw() {
      ctx.save();
      drawBackground(ctx);

      // Balls
      for (const b of balls) {
        b.draw(ctx);
      }

      // Pops
      for (const p of pops) {
        p.draw(ctx);
      }

      // Aim overlay
      drawAim(ctx);
      ctx.restore();
    }
  </script>
</body>
</html>
